import json
import boto3

# Bedrock client used to interact with APIs around models
bedrock_runtime = boto3.client(
    service_name='bedrock-runtime',
    region_name="us-west-2",
    endpoint_url="https://bedrock-runtime.us-west-2.amazonaws.com",
)

# Define the questions
questions = [
    "During the past 30 days, about how often did you feel nervous? 1: All of the time 2: Most of the time 3: Some of the time 4: A little of the time 5: None of the time",
    "During the past 30 days, about how often did you feel hopeless? 1: All of the time 2: Most of the time 3: Some of the time 4: A little of the time 5: None of the time",
    "During the past 30 days, about how often did you feel restless or fidgety? 1: All of the time 2: Most of the time 3: Some of the time 4: A little of the time 5: None of the time",
    "During the past 30 days, about how often did you feel so depressed that nothing could cheer you up? 1: All of the time 2: Most of the time 3: Some of the time 4: A little of the time 5: None of the time",
    "During the past 30 days, about how often did you feel that everything was an effort? 1: All of the time 2: Most of the time 3: Some of the time 4: A little of the time 5: None of the time",
    "During the past 30 days, about how often did you feel worthless? 1: All of the time 2: Most of the time 3: Some of the time 4: A little of the time 5: None of the time"
]

def lambda_handler(event, context):
    try:
        print(f"Received event: {event}\nWith context: {context}")

        body = json.loads(event['body'])
        print(f"BODY: {body} {type(body)}")
        
        response = {'statusCode': 200, 'headers': {'Content-Type': 'application/json'}}
        
        if "answer" not in body:
            print('Starting Survey on Question 1')
            response_body = {
                'question_id': 1,
                'question': questions[0]
            }
        else:
            question_id = body.get("question_id")
            print(f'ON QUESTION {question_id}')
            
            answer = body.get("answer")
            follow_up_question = call_bedrock(questions[question_id - 1], answer)
            
            response_body = {
                'question_id': question_id + 1,
                'question': questions[question_id - 1],
                'follow_up_question': follow_up_question
            }
        
        response['body'] = json.dumps(response_body)
        print(f"RESPONSE: {json.dumps(response)}")
        return response

    except Exception as e:
        print(f"Error: {str(e)}")
        response = {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)}),
            'headers': {'Content-Type': 'application/json'}
        }
        return response

def call_bedrock(question, answer):
    prompt = f"""
    You are an AI designed to enhance the credibility of survey responses. Given the respondent's answer to the K6 survey question, your task is to generate one relevant follow-up question to verify the respondent's answer and gather more detailed information.
    Here is the K6 question: {question}.
    Here is the respondent's answer: {answer}.
    Do not generate the respondent's answer or give any other context, just provide one follow-up question.
    The generated question needs to be multiple choice questions with 5 potential answers.
    """
    body = json.dumps({
        "prompt": f"<s>[INST]{prompt}[/INST]",
        "max_tokens": 400,
        "top_k": 50,
        "top_p": .7,
        "temperature": .7,
    })

    print(f"Bedrock Request Body: {body}")
    
    modelId = 'mistral.mistral-7b-instruct-v0:2'
    accept = 'application/json'
    contentType = 'application/json'

    response = bedrock_runtime.invoke_model(body=body, modelId=modelId, accept=accept, contentType=contentType)
    print(f"BEDROCK RESPONSE: {response}")

    response_content = response['body'].read().decode('utf-8')
    response_body = json.loads(response_content)
    response_text = response_body.get('outputs')[0].get('text')
    
    print(f"RESPONSE TEXT: {response_text}")
    return response_text
